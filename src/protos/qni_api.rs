// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `qni-api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StringArray {
    // message fields
    pub data: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringArray {
    fn default() -> &'a StringArray {
        <StringArray as ::protobuf::Message>::default_instance()
    }
}

impl StringArray {
    pub fn new() -> StringArray {
        ::std::default::Default::default()
    }

    // repeated string data = 1;


    pub fn get_data(&self) -> &[::std::string::String] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StringArray {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringArray {
        StringArray::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &StringArray| { &m.data },
                |m: &mut StringArray| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringArray>(
                "StringArray",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringArray {
        static instance: ::protobuf::rt::LazyV2<StringArray> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringArray::new)
    }
}

impl ::protobuf::Clear for StringArray {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringArray {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ErrorResponse {
    // message fields
    pub req_type: ::std::string::String,
    pub reason: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorResponse {
    fn default() -> &'a ErrorResponse {
        <ErrorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ErrorResponse {
    pub fn new() -> ErrorResponse {
        ::std::default::Default::default()
    }

    // string req_type = 1;


    pub fn get_req_type(&self) -> &str {
        &self.req_type
    }
    pub fn clear_req_type(&mut self) {
        self.req_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_req_type(&mut self, v: ::std::string::String) {
        self.req_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_req_type(&mut self) -> &mut ::std::string::String {
        &mut self.req_type
    }

    // Take field
    pub fn take_req_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.req_type, ::std::string::String::new())
    }

    // string reason = 2;


    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ErrorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.req_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.req_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.req_type);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.req_type.is_empty() {
            os.write_string(1, &self.req_type)?;
        }
        if !self.reason.is_empty() {
            os.write_string(2, &self.reason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErrorResponse {
        ErrorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "req_type",
                |m: &ErrorResponse| { &m.req_type },
                |m: &mut ErrorResponse| { &mut m.req_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &ErrorResponse| { &m.reason },
                |m: &mut ErrorResponse| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ErrorResponse>(
                "ErrorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ErrorResponse {
        static instance: ::protobuf::rt::LazyV2<ErrorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ErrorResponse::new)
    }
}

impl ::protobuf::Clear for ErrorResponse {
    fn clear(&mut self) {
        self.req_type.clear();
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InputRequest {
    // message fields
    pub expire: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub data: ::std::option::Option<InputRequest_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputRequest {
    fn default() -> &'a InputRequest {
        <InputRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum InputRequest_oneof_data {
    TOUCH(::protobuf::well_known_types::Empty),
    ENTER(::protobuf::well_known_types::Empty),
    ANYKEY(::protobuf::well_known_types::Empty),
    BOOLEAN(::protobuf::well_known_types::Empty),
    STR(::protobuf::well_known_types::Empty),
    STR_MAX_LEN(u32),
    STR_SELECT(StringArray),
    INT(::protobuf::well_known_types::Empty),
    INT_MAX_LEN(u32),
    FLOAT(::protobuf::well_known_types::Empty),
    FLOAT_MAX_LEN(u32),
    DATE(::protobuf::well_known_types::Empty),
    DATETIME(::protobuf::well_known_types::Empty),
    TIME(::protobuf::well_known_types::Empty),
    COLOR(::protobuf::well_known_types::Empty),
}

impl InputRequest {
    pub fn new() -> InputRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp expire = 1;


    pub fn get_expire(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expire.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expire(&mut self) {
        self.expire.clear();
    }

    pub fn has_expire(&self) -> bool {
        self.expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expire = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expire(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expire.is_none() {
            self.expire.set_default();
        }
        self.expire.as_mut().unwrap()
    }

    // Take field
    pub fn take_expire(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expire.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Empty TOUCH = 10;


    pub fn get_TOUCH(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_TOUCH(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_TOUCH(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_TOUCH(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_TOUCH(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_TOUCH(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_TOUCH() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty ENTER = 11;


    pub fn get_ENTER(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::ENTER(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ENTER(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_ENTER(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::ENTER(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ENTER(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::ENTER(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ENTER(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::ENTER(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::ENTER(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::ENTER(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ENTER(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_ENTER() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::ENTER(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty ANYKEY = 12;


    pub fn get_ANYKEY(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ANYKEY(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_ANYKEY(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ANYKEY(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ANYKEY(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ANYKEY(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_ANYKEY() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty BOOLEAN = 13;


    pub fn get_BOOLEAN(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_BOOLEAN(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_BOOLEAN(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BOOLEAN(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_BOOLEAN(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_BOOLEAN(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_BOOLEAN() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty STR = 20;


    pub fn get_STR(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_STR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_STR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_STR(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR(v))
    }

    // Mutable pointer to the field.
    pub fn mut_STR(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::STR(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_STR(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_STR() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::STR(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // uint32 STR_MAX_LEN = 21;


    pub fn get_STR_MAX_LEN(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR_MAX_LEN(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_STR_MAX_LEN(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_STR_MAX_LEN(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR_MAX_LEN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_STR_MAX_LEN(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR_MAX_LEN(v))
    }

    // .qni.api.StringArray STR_SELECT = 22;


    pub fn get_STR_SELECT(&self) -> &StringArray {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(ref v)) => v,
            _ => <StringArray as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_STR_SELECT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_STR_SELECT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_STR_SELECT(&mut self, v: StringArray) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_STR_SELECT(&mut self) -> &mut StringArray {
        if let ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(StringArray::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_STR_SELECT(&mut self) -> StringArray {
        if self.has_STR_SELECT() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(v)) => v,
                _ => panic!(),
            }
        } else {
            StringArray::new()
        }
    }

    // .google.protobuf.Empty INT = 30;


    pub fn get_INT(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::INT(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_INT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_INT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::INT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_INT(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::INT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_INT(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::INT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::INT(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::INT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_INT(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_INT() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::INT(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // uint32 INT_MAX_LEN = 31;


    pub fn get_INT_MAX_LEN(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::INT_MAX_LEN(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_INT_MAX_LEN(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_INT_MAX_LEN(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::INT_MAX_LEN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_INT_MAX_LEN(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::INT_MAX_LEN(v))
    }

    // .google.protobuf.Empty FLOAT = 40;


    pub fn get_FLOAT(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_FLOAT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_FLOAT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FLOAT(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FLOAT(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FLOAT(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_FLOAT() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // uint32 FLOAT_MAX_LEN = 41;


    pub fn get_FLOAT_MAX_LEN(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::FLOAT_MAX_LEN(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_FLOAT_MAX_LEN(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_FLOAT_MAX_LEN(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::FLOAT_MAX_LEN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FLOAT_MAX_LEN(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::FLOAT_MAX_LEN(v))
    }

    // .google.protobuf.Empty DATE = 50;


    pub fn get_DATE(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::DATE(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_DATE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_DATE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::DATE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DATE(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::DATE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DATE(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::DATE(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::DATE(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::DATE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DATE(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_DATE() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::DATE(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty DATETIME = 51;


    pub fn get_DATETIME(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_DATETIME(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_DATETIME(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DATETIME(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DATETIME(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DATETIME(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_DATETIME() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty TIME = 52;


    pub fn get_TIME(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::TIME(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_TIME(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_TIME(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::TIME(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_TIME(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::TIME(v))
    }

    // Mutable pointer to the field.
    pub fn mut_TIME(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::TIME(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::TIME(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::TIME(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_TIME(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_TIME() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::TIME(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty COLOR = 60;


    pub fn get_COLOR(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::COLOR(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_COLOR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_COLOR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::COLOR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_COLOR(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputRequest_oneof_data::COLOR(v))
    }

    // Mutable pointer to the field.
    pub fn mut_COLOR(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputRequest_oneof_data::COLOR(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputRequest_oneof_data::COLOR(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputRequest_oneof_data::COLOR(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_COLOR(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_COLOR() {
            match self.data.take() {
                ::std::option::Option::Some(InputRequest_oneof_data::COLOR(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }
}

impl ::protobuf::Message for InputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.expire {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(InputRequest_oneof_data::TOUCH(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::ENTER(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::ANYKEY(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::BOOLEAN(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::STR(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::STR_SELECT(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::INT(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::FLOAT(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::DATE(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::DATETIME(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::TIME(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputRequest_oneof_data::COLOR(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expire)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::TOUCH(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::ENTER(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::ANYKEY(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::BOOLEAN(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR_MAX_LEN(is.read_uint32()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::STR_SELECT(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::INT(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::INT_MAX_LEN(is.read_uint32()?));
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::FLOAT(is.read_message()?));
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::FLOAT_MAX_LEN(is.read_uint32()?));
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::DATE(is.read_message()?));
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::DATETIME(is.read_message()?));
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::TIME(is.read_message()?));
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputRequest_oneof_data::COLOR(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.expire.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &InputRequest_oneof_data::TOUCH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::ENTER(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::ANYKEY(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::BOOLEAN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::STR(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::STR_MAX_LEN(v) => {
                    my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &InputRequest_oneof_data::STR_SELECT(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::INT(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::INT_MAX_LEN(v) => {
                    my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &InputRequest_oneof_data::FLOAT(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::FLOAT_MAX_LEN(v) => {
                    my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &InputRequest_oneof_data::DATE(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::DATETIME(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::TIME(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputRequest_oneof_data::COLOR(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.expire.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &InputRequest_oneof_data::TOUCH(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::ENTER(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::ANYKEY(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::BOOLEAN(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::STR(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::STR_MAX_LEN(v) => {
                    os.write_uint32(21, v)?;
                },
                &InputRequest_oneof_data::STR_SELECT(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::INT(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::INT_MAX_LEN(v) => {
                    os.write_uint32(31, v)?;
                },
                &InputRequest_oneof_data::FLOAT(ref v) => {
                    os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::FLOAT_MAX_LEN(v) => {
                    os.write_uint32(41, v)?;
                },
                &InputRequest_oneof_data::DATE(ref v) => {
                    os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::DATETIME(ref v) => {
                    os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::TIME(ref v) => {
                    os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputRequest_oneof_data::COLOR(ref v) => {
                    os.write_tag(60, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputRequest {
        InputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expire",
                |m: &InputRequest| { &m.expire },
                |m: &mut InputRequest| { &mut m.expire },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "TOUCH",
                InputRequest::has_TOUCH,
                InputRequest::get_TOUCH,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "ENTER",
                InputRequest::has_ENTER,
                InputRequest::get_ENTER,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "ANYKEY",
                InputRequest::has_ANYKEY,
                InputRequest::get_ANYKEY,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "BOOLEAN",
                InputRequest::has_BOOLEAN,
                InputRequest::get_BOOLEAN,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "STR",
                InputRequest::has_STR,
                InputRequest::get_STR,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "STR_MAX_LEN",
                InputRequest::has_STR_MAX_LEN,
                InputRequest::get_STR_MAX_LEN,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StringArray>(
                "STR_SELECT",
                InputRequest::has_STR_SELECT,
                InputRequest::get_STR_SELECT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "INT",
                InputRequest::has_INT,
                InputRequest::get_INT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "INT_MAX_LEN",
                InputRequest::has_INT_MAX_LEN,
                InputRequest::get_INT_MAX_LEN,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "FLOAT",
                InputRequest::has_FLOAT,
                InputRequest::get_FLOAT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "FLOAT_MAX_LEN",
                InputRequest::has_FLOAT_MAX_LEN,
                InputRequest::get_FLOAT_MAX_LEN,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "DATE",
                InputRequest::has_DATE,
                InputRequest::get_DATE,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "DATETIME",
                InputRequest::has_DATETIME,
                InputRequest::get_DATETIME,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "TIME",
                InputRequest::has_TIME,
                InputRequest::get_TIME,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "COLOR",
                InputRequest::has_COLOR,
                InputRequest::get_COLOR,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputRequest>(
                "InputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputRequest {
        static instance: ::protobuf::rt::LazyV2<InputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputRequest::new)
    }
}

impl ::protobuf::Clear for InputRequest {
    fn clear(&mut self) {
        self.expire.clear();
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InputResponse {
    // message oneof groups
    pub data: ::std::option::Option<InputResponse_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputResponse {
    fn default() -> &'a InputResponse {
        <InputResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum InputResponse_oneof_data {
    EMPTY(::protobuf::well_known_types::Empty),
    BOOLEAN(bool),
    STR(::std::string::String),
    INT(i32),
    FLOAT(f32),
    DATE(::protobuf::well_known_types::Timestamp),
    DATETIME(::protobuf::well_known_types::Timestamp),
    TIME(::protobuf::well_known_types::Duration),
    COLOR(u32),
}

impl InputResponse {
    pub fn new() -> InputResponse {
        ::std::default::Default::default()
    }

    // .google.protobuf.Empty EMPTY = 10;


    pub fn get_EMPTY(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_EMPTY(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_EMPTY(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EMPTY(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EMPTY(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EMPTY(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_EMPTY() {
            match self.data.take() {
                ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // bool BOOLEAN = 20;


    pub fn get_BOOLEAN(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::BOOLEAN(v)) => v,
            _ => false,
        }
    }
    pub fn clear_BOOLEAN(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_BOOLEAN(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::BOOLEAN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BOOLEAN(&mut self, v: bool) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::BOOLEAN(v))
    }

    // string STR = 21;


    pub fn get_STR(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::STR(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_STR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_STR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::STR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_STR(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::STR(v))
    }

    // Mutable pointer to the field.
    pub fn mut_STR(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(InputResponse_oneof_data::STR(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputResponse_oneof_data::STR(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::STR(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_STR(&mut self) -> ::std::string::String {
        if self.has_STR() {
            match self.data.take() {
                ::std::option::Option::Some(InputResponse_oneof_data::STR(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int32 INT = 22;


    pub fn get_INT(&self) -> i32 {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::INT(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_INT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_INT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::INT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_INT(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::INT(v))
    }

    // float FLOAT = 23;


    pub fn get_FLOAT(&self) -> f32 {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::FLOAT(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_FLOAT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_FLOAT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::FLOAT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FLOAT(&mut self, v: f32) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::FLOAT(v))
    }

    // .google.protobuf.Timestamp DATE = 30;


    pub fn get_DATE(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::DATE(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_DATE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_DATE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::DATE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DATE(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::DATE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DATE(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(InputResponse_oneof_data::DATE(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputResponse_oneof_data::DATE(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::DATE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DATE(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_DATE() {
            match self.data.take() {
                ::std::option::Option::Some(InputResponse_oneof_data::DATE(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // .google.protobuf.Timestamp DATETIME = 31;


    pub fn get_DATETIME(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_DATETIME(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_DATETIME(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DATETIME(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DATETIME(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DATETIME(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_DATETIME() {
            match self.data.take() {
                ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // .google.protobuf.Duration TIME = 32;


    pub fn get_TIME(&self) -> &::protobuf::well_known_types::Duration {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::TIME(ref v)) => v,
            _ => <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_TIME(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_TIME(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::TIME(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_TIME(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::TIME(v))
    }

    // Mutable pointer to the field.
    pub fn mut_TIME(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(InputResponse_oneof_data::TIME(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InputResponse_oneof_data::TIME(::protobuf::well_known_types::Duration::new()));
        }
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::TIME(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_TIME(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_TIME() {
            match self.data.take() {
                ::std::option::Option::Some(InputResponse_oneof_data::TIME(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // uint32 COLOR = 40;


    pub fn get_COLOR(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::COLOR(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_COLOR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_COLOR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InputResponse_oneof_data::COLOR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_COLOR(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(InputResponse_oneof_data::COLOR(v))
    }
}

impl ::protobuf::Message for InputResponse {
    fn is_initialized(&self) -> bool {
        if let Some(InputResponse_oneof_data::EMPTY(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputResponse_oneof_data::DATE(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputResponse_oneof_data::DATETIME(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InputResponse_oneof_data::TIME(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::EMPTY(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::BOOLEAN(is.read_bool()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::STR(is.read_string()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::INT(is.read_int32()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::FLOAT(is.read_float()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::DATE(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::DATETIME(is.read_message()?));
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::TIME(is.read_message()?));
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InputResponse_oneof_data::COLOR(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &InputResponse_oneof_data::EMPTY(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputResponse_oneof_data::BOOLEAN(v) => {
                    my_size += 3;
                },
                &InputResponse_oneof_data::STR(ref v) => {
                    my_size += ::protobuf::rt::string_size(21, &v);
                },
                &InputResponse_oneof_data::INT(v) => {
                    my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &InputResponse_oneof_data::FLOAT(v) => {
                    my_size += 6;
                },
                &InputResponse_oneof_data::DATE(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputResponse_oneof_data::DATETIME(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputResponse_oneof_data::TIME(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InputResponse_oneof_data::COLOR(v) => {
                    my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &InputResponse_oneof_data::EMPTY(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputResponse_oneof_data::BOOLEAN(v) => {
                    os.write_bool(20, v)?;
                },
                &InputResponse_oneof_data::STR(ref v) => {
                    os.write_string(21, v)?;
                },
                &InputResponse_oneof_data::INT(v) => {
                    os.write_int32(22, v)?;
                },
                &InputResponse_oneof_data::FLOAT(v) => {
                    os.write_float(23, v)?;
                },
                &InputResponse_oneof_data::DATE(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputResponse_oneof_data::DATETIME(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputResponse_oneof_data::TIME(ref v) => {
                    os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InputResponse_oneof_data::COLOR(v) => {
                    os.write_uint32(40, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputResponse {
        InputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "EMPTY",
                InputResponse::has_EMPTY,
                InputResponse::get_EMPTY,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "BOOLEAN",
                InputResponse::has_BOOLEAN,
                InputResponse::get_BOOLEAN,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "STR",
                InputResponse::has_STR,
                InputResponse::get_STR,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "INT",
                InputResponse::has_INT,
                InputResponse::get_INT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "FLOAT",
                InputResponse::has_FLOAT,
                InputResponse::get_FLOAT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "DATE",
                InputResponse::has_DATE,
                InputResponse::get_DATE,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "DATETIME",
                InputResponse::has_DATETIME,
                InputResponse::get_DATETIME,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                "TIME",
                InputResponse::has_TIME,
                InputResponse::get_TIME,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "COLOR",
                InputResponse::has_COLOR,
                InputResponse::get_COLOR,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputResponse>(
                "InputResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputResponse {
        static instance: ::protobuf::rt::LazyV2<InputResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputResponse::new)
    }
}

impl ::protobuf::Clear for InputResponse {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConsolePrintButtonData {
    // message fields
    pub value: ::protobuf::SingularPtrField<InputResponse>,
    pub text: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsolePrintButtonData {
    fn default() -> &'a ConsolePrintButtonData {
        <ConsolePrintButtonData as ::protobuf::Message>::default_instance()
    }
}

impl ConsolePrintButtonData {
    pub fn new() -> ConsolePrintButtonData {
        ::std::default::Default::default()
    }

    // .qni.api.InputResponse value = 1;


    pub fn get_value(&self) -> &InputResponse {
        self.value.as_ref().unwrap_or_else(|| <InputResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: InputResponse) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut InputResponse {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> InputResponse {
        self.value.take().unwrap_or_else(|| InputResponse::new())
    }

    // string text = 2;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConsolePrintButtonData {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.text.is_empty() {
            os.write_string(2, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsolePrintButtonData {
        ConsolePrintButtonData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputResponse>>(
                "value",
                |m: &ConsolePrintButtonData| { &m.value },
                |m: &mut ConsolePrintButtonData| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &ConsolePrintButtonData| { &m.text },
                |m: &mut ConsolePrintButtonData| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsolePrintButtonData>(
                "ConsolePrintButtonData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsolePrintButtonData {
        static instance: ::protobuf::rt::LazyV2<ConsolePrintButtonData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsolePrintButtonData::new)
    }
}

impl ::protobuf::Clear for ConsolePrintButtonData {
    fn clear(&mut self) {
        self.value.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsolePrintButtonData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsolePrintButtonData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConsolePrintData {
    // message oneof groups
    pub data: ::std::option::Option<ConsolePrintData_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsolePrintData {
    fn default() -> &'a ConsolePrintData {
        <ConsolePrintData as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ConsolePrintData_oneof_data {
    PRINT(::std::string::String),
    PRINT_LINE(::std::string::String),
    PRINT_BUTTON(ConsolePrintButtonData),
    NEW_LINE(::protobuf::well_known_types::Empty),
    DRAW_LINE(::protobuf::well_known_types::Empty),
    DELETE_LINE(u32),
    CLEAR_LINE(::protobuf::well_known_types::Empty),
}

impl ConsolePrintData {
    pub fn new() -> ConsolePrintData {
        ::std::default::Default::default()
    }

    // string PRINT = 10;


    pub fn get_PRINT(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_PRINT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_PRINT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PRINT(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PRINT(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PRINT(&mut self) -> ::std::string::String {
        if self.has_PRINT() {
            match self.data.take() {
                ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string PRINT_LINE = 11;


    pub fn get_PRINT_LINE(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_PRINT_LINE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_PRINT_LINE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PRINT_LINE(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PRINT_LINE(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PRINT_LINE(&mut self) -> ::std::string::String {
        if self.has_PRINT_LINE() {
            match self.data.take() {
                ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .qni.api.ConsolePrintButtonData PRINT_BUTTON = 12;


    pub fn get_PRINT_BUTTON(&self) -> &ConsolePrintButtonData {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(ref v)) => v,
            _ => <ConsolePrintButtonData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_PRINT_BUTTON(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_PRINT_BUTTON(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PRINT_BUTTON(&mut self, v: ConsolePrintButtonData) {
        self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PRINT_BUTTON(&mut self) -> &mut ConsolePrintButtonData {
        if let ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(ConsolePrintButtonData::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PRINT_BUTTON(&mut self) -> ConsolePrintButtonData {
        if self.has_PRINT_BUTTON() {
            match self.data.take() {
                ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(v)) => v,
                _ => panic!(),
            }
        } else {
            ConsolePrintButtonData::new()
        }
    }

    // .google.protobuf.Empty NEW_LINE = 20;


    pub fn get_NEW_LINE(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_NEW_LINE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_NEW_LINE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NEW_LINE(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NEW_LINE(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NEW_LINE(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_NEW_LINE() {
            match self.data.take() {
                ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty DRAW_LINE = 21;


    pub fn get_DRAW_LINE(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_DRAW_LINE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_DRAW_LINE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DRAW_LINE(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DRAW_LINE(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DRAW_LINE(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_DRAW_LINE() {
            match self.data.take() {
                ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // uint32 DELETE_LINE = 30;


    pub fn get_DELETE_LINE(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::DELETE_LINE(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_DELETE_LINE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_DELETE_LINE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::DELETE_LINE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DELETE_LINE(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::DELETE_LINE(v))
    }

    // .google.protobuf.Empty CLEAR_LINE = 31;


    pub fn get_CLEAR_LINE(&self) -> &::protobuf::well_known_types::Empty {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_CLEAR_LINE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_CLEAR_LINE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_CLEAR_LINE(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_CLEAR_LINE(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(::protobuf::well_known_types::Empty::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_CLEAR_LINE(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_CLEAR_LINE() {
            match self.data.take() {
                ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }
}

impl ::protobuf::Message for ConsolePrintData {
    fn is_initialized(&self) -> bool {
        if let Some(ConsolePrintData_oneof_data::PRINT_BUTTON(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsolePrintData_oneof_data::NEW_LINE(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsolePrintData_oneof_data::DRAW_LINE(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsolePrintData_oneof_data::CLEAR_LINE(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT(is.read_string()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_LINE(is.read_string()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::PRINT_BUTTON(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::NEW_LINE(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::DRAW_LINE(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::DELETE_LINE(is.read_uint32()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsolePrintData_oneof_data::CLEAR_LINE(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsolePrintData_oneof_data::PRINT(ref v) => {
                    my_size += ::protobuf::rt::string_size(10, &v);
                },
                &ConsolePrintData_oneof_data::PRINT_LINE(ref v) => {
                    my_size += ::protobuf::rt::string_size(11, &v);
                },
                &ConsolePrintData_oneof_data::PRINT_BUTTON(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsolePrintData_oneof_data::NEW_LINE(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsolePrintData_oneof_data::DRAW_LINE(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsolePrintData_oneof_data::DELETE_LINE(v) => {
                    my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &ConsolePrintData_oneof_data::CLEAR_LINE(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsolePrintData_oneof_data::PRINT(ref v) => {
                    os.write_string(10, v)?;
                },
                &ConsolePrintData_oneof_data::PRINT_LINE(ref v) => {
                    os.write_string(11, v)?;
                },
                &ConsolePrintData_oneof_data::PRINT_BUTTON(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsolePrintData_oneof_data::NEW_LINE(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsolePrintData_oneof_data::DRAW_LINE(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsolePrintData_oneof_data::DELETE_LINE(v) => {
                    os.write_uint32(30, v)?;
                },
                &ConsolePrintData_oneof_data::CLEAR_LINE(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsolePrintData {
        ConsolePrintData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "PRINT",
                ConsolePrintData::has_PRINT,
                ConsolePrintData::get_PRINT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "PRINT_LINE",
                ConsolePrintData::has_PRINT_LINE,
                ConsolePrintData::get_PRINT_LINE,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConsolePrintButtonData>(
                "PRINT_BUTTON",
                ConsolePrintData::has_PRINT_BUTTON,
                ConsolePrintData::get_PRINT_BUTTON,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "NEW_LINE",
                ConsolePrintData::has_NEW_LINE,
                ConsolePrintData::get_NEW_LINE,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "DRAW_LINE",
                ConsolePrintData::has_DRAW_LINE,
                ConsolePrintData::get_DRAW_LINE,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "DELETE_LINE",
                ConsolePrintData::has_DELETE_LINE,
                ConsolePrintData::get_DELETE_LINE,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "CLEAR_LINE",
                ConsolePrintData::has_CLEAR_LINE,
                ConsolePrintData::get_CLEAR_LINE,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsolePrintData>(
                "ConsolePrintData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsolePrintData {
        static instance: ::protobuf::rt::LazyV2<ConsolePrintData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsolePrintData::new)
    }
}

impl ::protobuf::Clear for ConsolePrintData {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsolePrintData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsolePrintData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Font {
    // message fields
    pub font_family: ::std::string::String,
    pub font_size: f32,
    pub font_style: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Font {
    fn default() -> &'a Font {
        <Font as ::protobuf::Message>::default_instance()
    }
}

impl Font {
    pub fn new() -> Font {
        ::std::default::Default::default()
    }

    // string font_family = 1;


    pub fn get_font_family(&self) -> &str {
        &self.font_family
    }
    pub fn clear_font_family(&mut self) {
        self.font_family.clear();
    }

    // Param is passed by value, moved
    pub fn set_font_family(&mut self, v: ::std::string::String) {
        self.font_family = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_font_family(&mut self) -> &mut ::std::string::String {
        &mut self.font_family
    }

    // Take field
    pub fn take_font_family(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.font_family, ::std::string::String::new())
    }

    // float font_size = 2;


    pub fn get_font_size(&self) -> f32 {
        self.font_size
    }
    pub fn clear_font_size(&mut self) {
        self.font_size = 0.;
    }

    // Param is passed by value, moved
    pub fn set_font_size(&mut self, v: f32) {
        self.font_size = v;
    }

    // uint32 font_style = 3;


    pub fn get_font_style(&self) -> u32 {
        self.font_style
    }
    pub fn clear_font_style(&mut self) {
        self.font_style = 0;
    }

    // Param is passed by value, moved
    pub fn set_font_style(&mut self, v: u32) {
        self.font_style = v;
    }
}

impl ::protobuf::Message for Font {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.font_family)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.font_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.font_style = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.font_family.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.font_family);
        }
        if self.font_size != 0. {
            my_size += 5;
        }
        if self.font_style != 0 {
            my_size += ::protobuf::rt::value_size(3, self.font_style, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.font_family.is_empty() {
            os.write_string(1, &self.font_family)?;
        }
        if self.font_size != 0. {
            os.write_float(2, self.font_size)?;
        }
        if self.font_style != 0 {
            os.write_uint32(3, self.font_style)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Font {
        Font::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "font_family",
                |m: &Font| { &m.font_family },
                |m: &mut Font| { &mut m.font_family },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "font_size",
                |m: &Font| { &m.font_size },
                |m: &mut Font| { &mut m.font_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "font_style",
                |m: &Font| { &m.font_style },
                |m: &mut Font| { &mut m.font_style },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Font>(
                "Font",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Font {
        static instance: ::protobuf::rt::LazyV2<Font> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Font::new)
    }
}

impl ::protobuf::Clear for Font {
    fn clear(&mut self) {
        self.font_family.clear();
        self.font_size = 0.;
        self.font_style = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Font {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Font {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConsoleSettingItem {
    // message oneof groups
    pub data: ::std::option::Option<ConsoleSettingItem_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsoleSettingItem {
    fn default() -> &'a ConsoleSettingItem {
        <ConsoleSettingItem as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ConsoleSettingItem_oneof_data {
    TEXT_COLOR(u32),
    BACK_COLOR(u32),
    HIGHLIGHT_COLOR(u32),
    FONT(Font),
    TEXT_ALIGN(TextAlign),
}

impl ConsoleSettingItem {
    pub fn new() -> ConsoleSettingItem {
        ::std::default::Default::default()
    }

    // uint32 TEXT_COLOR = 10;


    pub fn get_TEXT_COLOR(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_COLOR(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_TEXT_COLOR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_TEXT_COLOR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_COLOR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_TEXT_COLOR(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_COLOR(v))
    }

    // uint32 BACK_COLOR = 11;


    pub fn get_BACK_COLOR(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::BACK_COLOR(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_BACK_COLOR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_BACK_COLOR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::BACK_COLOR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BACK_COLOR(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::BACK_COLOR(v))
    }

    // uint32 HIGHLIGHT_COLOR = 12;


    pub fn get_HIGHLIGHT_COLOR(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::HIGHLIGHT_COLOR(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_HIGHLIGHT_COLOR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_HIGHLIGHT_COLOR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::HIGHLIGHT_COLOR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HIGHLIGHT_COLOR(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::HIGHLIGHT_COLOR(v))
    }

    // .qni.api.Font FONT = 20;


    pub fn get_FONT(&self) -> &Font {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(ref v)) => v,
            _ => <Font as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_FONT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_FONT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FONT(&mut self, v: Font) {
        self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FONT(&mut self) -> &mut Font {
        if let ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(Font::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FONT(&mut self) -> Font {
        if self.has_FONT() {
            match self.data.take() {
                ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(v)) => v,
                _ => panic!(),
            }
        } else {
            Font::new()
        }
    }

    // .qni.api.TextAlign TEXT_ALIGN = 21;


    pub fn get_TEXT_ALIGN(&self) -> TextAlign {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_ALIGN(v)) => v,
            _ => TextAlign::LEFT,
        }
    }
    pub fn clear_TEXT_ALIGN(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_TEXT_ALIGN(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_ALIGN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_TEXT_ALIGN(&mut self, v: TextAlign) {
        self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_ALIGN(v))
    }
}

impl ::protobuf::Message for ConsoleSettingItem {
    fn is_initialized(&self) -> bool {
        if let Some(ConsoleSettingItem_oneof_data::FONT(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_COLOR(is.read_uint32()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::BACK_COLOR(is.read_uint32()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::HIGHLIGHT_COLOR(is.read_uint32()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::FONT(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleSettingItem_oneof_data::TEXT_ALIGN(is.read_enum()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleSettingItem_oneof_data::TEXT_COLOR(v) => {
                    my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &ConsoleSettingItem_oneof_data::BACK_COLOR(v) => {
                    my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &ConsoleSettingItem_oneof_data::HIGHLIGHT_COLOR(v) => {
                    my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &ConsoleSettingItem_oneof_data::FONT(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsoleSettingItem_oneof_data::TEXT_ALIGN(v) => {
                    my_size += ::protobuf::rt::enum_size(21, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleSettingItem_oneof_data::TEXT_COLOR(v) => {
                    os.write_uint32(10, v)?;
                },
                &ConsoleSettingItem_oneof_data::BACK_COLOR(v) => {
                    os.write_uint32(11, v)?;
                },
                &ConsoleSettingItem_oneof_data::HIGHLIGHT_COLOR(v) => {
                    os.write_uint32(12, v)?;
                },
                &ConsoleSettingItem_oneof_data::FONT(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsoleSettingItem_oneof_data::TEXT_ALIGN(v) => {
                    os.write_enum(21, ::protobuf::ProtobufEnum::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsoleSettingItem {
        ConsoleSettingItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "TEXT_COLOR",
                ConsoleSettingItem::has_TEXT_COLOR,
                ConsoleSettingItem::get_TEXT_COLOR,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "BACK_COLOR",
                ConsoleSettingItem::has_BACK_COLOR,
                ConsoleSettingItem::get_BACK_COLOR,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "HIGHLIGHT_COLOR",
                ConsoleSettingItem::has_HIGHLIGHT_COLOR,
                ConsoleSettingItem::get_HIGHLIGHT_COLOR,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Font>(
                "FONT",
                ConsoleSettingItem::has_FONT,
                ConsoleSettingItem::get_FONT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, TextAlign>(
                "TEXT_ALIGN",
                ConsoleSettingItem::has_TEXT_ALIGN,
                ConsoleSettingItem::get_TEXT_ALIGN,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsoleSettingItem>(
                "ConsoleSettingItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsoleSettingItem {
        static instance: ::protobuf::rt::LazyV2<ConsoleSettingItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsoleSettingItem::new)
    }
}

impl ::protobuf::Clear for ConsoleSettingItem {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsoleSettingItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsoleSettingItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConsoleRequest {
    // message oneof groups
    pub data: ::std::option::Option<ConsoleRequest_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsoleRequest {
    fn default() -> &'a ConsoleRequest {
        <ConsoleRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ConsoleRequest_oneof_data {
    GET_STATE(u64),
}

impl ConsoleRequest {
    pub fn new() -> ConsoleRequest {
        ::std::default::Default::default()
    }

    // uint64 GET_STATE = 20;


    pub fn get_GET_STATE(&self) -> u64 {
        match self.data {
            ::std::option::Option::Some(ConsoleRequest_oneof_data::GET_STATE(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_GET_STATE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_GET_STATE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleRequest_oneof_data::GET_STATE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_GET_STATE(&mut self, v: u64) {
        self.data = ::std::option::Option::Some(ConsoleRequest_oneof_data::GET_STATE(v))
    }
}

impl ::protobuf::Message for ConsoleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleRequest_oneof_data::GET_STATE(is.read_uint64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleRequest_oneof_data::GET_STATE(v) => {
                    my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleRequest_oneof_data::GET_STATE(v) => {
                    os.write_uint64(20, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsoleRequest {
        ConsoleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "GET_STATE",
                ConsoleRequest::has_GET_STATE,
                ConsoleRequest::get_GET_STATE,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsoleRequest>(
                "ConsoleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsoleRequest {
        static instance: ::protobuf::rt::LazyV2<ConsoleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsoleRequest::new)
    }
}

impl ::protobuf::Clear for ConsoleRequest {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsoleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsoleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConsoleResponse {
    // message fields
    pub tag: u32,
    // message oneof groups
    pub data: ::std::option::Option<ConsoleResponse_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsoleResponse {
    fn default() -> &'a ConsoleResponse {
        <ConsoleResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ConsoleResponse_oneof_data {
    OK_INPUT(InputResponse),
    ERR(ErrorResponse),
}

impl ConsoleResponse {
    pub fn new() -> ConsoleResponse {
        ::std::default::Default::default()
    }

    // uint32 tag = 1;


    pub fn get_tag(&self) -> u32 {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u32) {
        self.tag = v;
    }

    // .qni.api.InputResponse OK_INPUT = 10;


    pub fn get_OK_INPUT(&self) -> &InputResponse {
        match self.data {
            ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(ref v)) => v,
            _ => <InputResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_OK_INPUT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_OK_INPUT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_OK_INPUT(&mut self, v: InputResponse) {
        self.data = ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_OK_INPUT(&mut self) -> &mut InputResponse {
        if let ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(InputResponse::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_OK_INPUT(&mut self) -> InputResponse {
        if self.has_OK_INPUT() {
            match self.data.take() {
                ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(v)) => v,
                _ => panic!(),
            }
        } else {
            InputResponse::new()
        }
    }

    // .qni.api.ErrorResponse ERR = 255;


    pub fn get_ERR(&self) -> &ErrorResponse {
        match self.data {
            ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(ref v)) => v,
            _ => <ErrorResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ERR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_ERR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ERR(&mut self, v: ErrorResponse) {
        self.data = ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ERR(&mut self) -> &mut ErrorResponse {
        if let ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(ErrorResponse::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ERR(&mut self) -> ErrorResponse {
        if self.has_ERR() {
            match self.data.take() {
                ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(v)) => v,
                _ => panic!(),
            }
        } else {
            ErrorResponse::new()
        }
    }
}

impl ::protobuf::Message for ConsoleResponse {
    fn is_initialized(&self) -> bool {
        if let Some(ConsoleResponse_oneof_data::OK_INPUT(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsoleResponse_oneof_data::ERR(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tag = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleResponse_oneof_data::OK_INPUT(is.read_message()?));
                },
                255 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleResponse_oneof_data::ERR(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tag, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleResponse_oneof_data::OK_INPUT(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsoleResponse_oneof_data::ERR(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tag != 0 {
            os.write_uint32(1, self.tag)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleResponse_oneof_data::OK_INPUT(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsoleResponse_oneof_data::ERR(ref v) => {
                    os.write_tag(255, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsoleResponse {
        ConsoleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tag",
                |m: &ConsoleResponse| { &m.tag },
                |m: &mut ConsoleResponse| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InputResponse>(
                "OK_INPUT",
                ConsoleResponse::has_OK_INPUT,
                ConsoleResponse::get_OK_INPUT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ErrorResponse>(
                "ERR",
                ConsoleResponse::has_ERR,
                ConsoleResponse::get_ERR,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsoleResponse>(
                "ConsoleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsoleResponse {
        static instance: ::protobuf::rt::LazyV2<ConsoleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsoleResponse::new)
    }
}

impl ::protobuf::Clear for ConsoleResponse {
    fn clear(&mut self) {
        self.tag = 0;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsoleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConsoleMessage {
    // message oneof groups
    pub data: ::std::option::Option<ConsoleMessage_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsoleMessage {
    fn default() -> &'a ConsoleMessage {
        <ConsoleMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ConsoleMessage_oneof_data {
    REQ(ConsoleRequest),
    RES(ConsoleResponse),
}

impl ConsoleMessage {
    pub fn new() -> ConsoleMessage {
        ::std::default::Default::default()
    }

    // .qni.api.ConsoleRequest REQ = 10;


    pub fn get_REQ(&self) -> &ConsoleRequest {
        match self.data {
            ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(ref v)) => v,
            _ => <ConsoleRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_REQ(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_REQ(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_REQ(&mut self, v: ConsoleRequest) {
        self.data = ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(v))
    }

    // Mutable pointer to the field.
    pub fn mut_REQ(&mut self) -> &mut ConsoleRequest {
        if let ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(ConsoleRequest::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_REQ(&mut self) -> ConsoleRequest {
        if self.has_REQ() {
            match self.data.take() {
                ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(v)) => v,
                _ => panic!(),
            }
        } else {
            ConsoleRequest::new()
        }
    }

    // .qni.api.ConsoleResponse RES = 11;


    pub fn get_RES(&self) -> &ConsoleResponse {
        match self.data {
            ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(ref v)) => v,
            _ => <ConsoleResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_RES(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_RES(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_RES(&mut self, v: ConsoleResponse) {
        self.data = ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(v))
    }

    // Mutable pointer to the field.
    pub fn mut_RES(&mut self) -> &mut ConsoleResponse {
        if let ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(ConsoleResponse::new()));
        }
        match self.data {
            ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_RES(&mut self) -> ConsoleResponse {
        if self.has_RES() {
            match self.data.take() {
                ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(v)) => v,
                _ => panic!(),
            }
        } else {
            ConsoleResponse::new()
        }
    }
}

impl ::protobuf::Message for ConsoleMessage {
    fn is_initialized(&self) -> bool {
        if let Some(ConsoleMessage_oneof_data::REQ(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsoleMessage_oneof_data::RES(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleMessage_oneof_data::REQ(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ConsoleMessage_oneof_data::RES(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleMessage_oneof_data::REQ(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsoleMessage_oneof_data::RES(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ConsoleMessage_oneof_data::REQ(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsoleMessage_oneof_data::RES(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsoleMessage {
        ConsoleMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConsoleRequest>(
                "REQ",
                ConsoleMessage::has_REQ,
                ConsoleMessage::get_REQ,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConsoleResponse>(
                "RES",
                ConsoleMessage::has_RES,
                ConsoleMessage::get_RES,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsoleMessage>(
                "ConsoleMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsoleMessage {
        static instance: ::protobuf::rt::LazyV2<ConsoleMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsoleMessage::new)
    }
}

impl ::protobuf::Clear for ConsoleMessage {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsoleMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsoleMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProgramCommand {
    // message oneof groups
    pub data: ::std::option::Option<ProgramCommand_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProgramCommand {
    fn default() -> &'a ProgramCommand {
        <ProgramCommand as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ProgramCommand_oneof_data {
    PRINT(ConsolePrintData),
    UPDATE_SETTING(ConsoleSettingItem),
}

impl ProgramCommand {
    pub fn new() -> ProgramCommand {
        ::std::default::Default::default()
    }

    // .qni.api.ConsolePrintData PRINT = 10;


    pub fn get_PRINT(&self) -> &ConsolePrintData {
        match self.data {
            ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(ref v)) => v,
            _ => <ConsolePrintData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_PRINT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_PRINT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PRINT(&mut self, v: ConsolePrintData) {
        self.data = ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PRINT(&mut self) -> &mut ConsolePrintData {
        if let ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(ConsolePrintData::new()));
        }
        match self.data {
            ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PRINT(&mut self) -> ConsolePrintData {
        if self.has_PRINT() {
            match self.data.take() {
                ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(v)) => v,
                _ => panic!(),
            }
        } else {
            ConsolePrintData::new()
        }
    }

    // .qni.api.ConsoleSettingItem UPDATE_SETTING = 11;


    pub fn get_UPDATE_SETTING(&self) -> &ConsoleSettingItem {
        match self.data {
            ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(ref v)) => v,
            _ => <ConsoleSettingItem as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_UPDATE_SETTING(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_UPDATE_SETTING(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_UPDATE_SETTING(&mut self, v: ConsoleSettingItem) {
        self.data = ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(v))
    }

    // Mutable pointer to the field.
    pub fn mut_UPDATE_SETTING(&mut self) -> &mut ConsoleSettingItem {
        if let ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(ConsoleSettingItem::new()));
        }
        match self.data {
            ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_UPDATE_SETTING(&mut self) -> ConsoleSettingItem {
        if self.has_UPDATE_SETTING() {
            match self.data.take() {
                ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(v)) => v,
                _ => panic!(),
            }
        } else {
            ConsoleSettingItem::new()
        }
    }
}

impl ::protobuf::Message for ProgramCommand {
    fn is_initialized(&self) -> bool {
        if let Some(ProgramCommand_oneof_data::PRINT(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProgramCommand_oneof_data::UPDATE_SETTING(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramCommand_oneof_data::PRINT(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramCommand_oneof_data::UPDATE_SETTING(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramCommand_oneof_data::PRINT(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProgramCommand_oneof_data::UPDATE_SETTING(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramCommand_oneof_data::PRINT(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProgramCommand_oneof_data::UPDATE_SETTING(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramCommand {
        ProgramCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConsolePrintData>(
                "PRINT",
                ProgramCommand::has_PRINT,
                ProgramCommand::get_PRINT,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConsoleSettingItem>(
                "UPDATE_SETTING",
                ProgramCommand::has_UPDATE_SETTING,
                ProgramCommand::get_UPDATE_SETTING,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProgramCommand>(
                "ProgramCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProgramCommand {
        static instance: ::protobuf::rt::LazyV2<ProgramCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProgramCommand::new)
    }
}

impl ::protobuf::Clear for ProgramCommand {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProgramCommandArray {
    // message fields
    pub commands: ::protobuf::RepeatedField<ProgramCommand>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProgramCommandArray {
    fn default() -> &'a ProgramCommandArray {
        <ProgramCommandArray as ::protobuf::Message>::default_instance()
    }
}

impl ProgramCommandArray {
    pub fn new() -> ProgramCommandArray {
        ::std::default::Default::default()
    }

    // repeated .qni.api.ProgramCommand commands = 1;


    pub fn get_commands(&self) -> &[ProgramCommand] {
        &self.commands
    }
    pub fn clear_commands(&mut self) {
        self.commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_commands(&mut self, v: ::protobuf::RepeatedField<ProgramCommand>) {
        self.commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commands(&mut self) -> &mut ::protobuf::RepeatedField<ProgramCommand> {
        &mut self.commands
    }

    // Take field
    pub fn take_commands(&mut self) -> ::protobuf::RepeatedField<ProgramCommand> {
        ::std::mem::replace(&mut self.commands, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProgramCommandArray {
    fn is_initialized(&self) -> bool {
        for v in &self.commands {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.commands)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.commands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.commands {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramCommandArray {
        ProgramCommandArray::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProgramCommand>>(
                "commands",
                |m: &ProgramCommandArray| { &m.commands },
                |m: &mut ProgramCommandArray| { &mut m.commands },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProgramCommandArray>(
                "ProgramCommandArray",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProgramCommandArray {
        static instance: ::protobuf::rt::LazyV2<ProgramCommandArray> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProgramCommandArray::new)
    }
}

impl ::protobuf::Clear for ProgramCommandArray {
    fn clear(&mut self) {
        self.commands.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramCommandArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramCommandArray {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProgramRequest {
    // message fields
    pub tag: u32,
    // message oneof groups
    pub data: ::std::option::Option<ProgramRequest_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProgramRequest {
    fn default() -> &'a ProgramRequest {
        <ProgramRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ProgramRequest_oneof_data {
    INPUT(InputRequest),
}

impl ProgramRequest {
    pub fn new() -> ProgramRequest {
        ::std::default::Default::default()
    }

    // uint32 tag = 1;


    pub fn get_tag(&self) -> u32 {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u32) {
        self.tag = v;
    }

    // .qni.api.InputRequest INPUT = 10;


    pub fn get_INPUT(&self) -> &InputRequest {
        match self.data {
            ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(ref v)) => v,
            _ => <InputRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_INPUT(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_INPUT(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_INPUT(&mut self, v: InputRequest) {
        self.data = ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(v))
    }

    // Mutable pointer to the field.
    pub fn mut_INPUT(&mut self) -> &mut InputRequest {
        if let ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(InputRequest::new()));
        }
        match self.data {
            ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_INPUT(&mut self) -> InputRequest {
        if self.has_INPUT() {
            match self.data.take() {
                ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(v)) => v,
                _ => panic!(),
            }
        } else {
            InputRequest::new()
        }
    }
}

impl ::protobuf::Message for ProgramRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ProgramRequest_oneof_data::INPUT(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tag = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramRequest_oneof_data::INPUT(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tag, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramRequest_oneof_data::INPUT(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tag != 0 {
            os.write_uint32(1, self.tag)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramRequest_oneof_data::INPUT(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramRequest {
        ProgramRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tag",
                |m: &ProgramRequest| { &m.tag },
                |m: &mut ProgramRequest| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InputRequest>(
                "INPUT",
                ProgramRequest::has_INPUT,
                ProgramRequest::get_INPUT,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProgramRequest>(
                "ProgramRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProgramRequest {
        static instance: ::protobuf::rt::LazyV2<ProgramRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProgramRequest::new)
    }
}

impl ::protobuf::Clear for ProgramRequest {
    fn clear(&mut self) {
        self.tag = 0;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProgramResponse {
    // message oneof groups
    pub data: ::std::option::Option<ProgramResponse_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProgramResponse {
    fn default() -> &'a ProgramResponse {
        <ProgramResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ProgramResponse_oneof_data {
    OK_GET_STATE(ProgramCommandArray),
    ERR(ErrorResponse),
}

impl ProgramResponse {
    pub fn new() -> ProgramResponse {
        ::std::default::Default::default()
    }

    // .qni.api.ProgramCommandArray OK_GET_STATE = 12;


    pub fn get_OK_GET_STATE(&self) -> &ProgramCommandArray {
        match self.data {
            ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(ref v)) => v,
            _ => <ProgramCommandArray as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_OK_GET_STATE(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_OK_GET_STATE(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_OK_GET_STATE(&mut self, v: ProgramCommandArray) {
        self.data = ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_OK_GET_STATE(&mut self) -> &mut ProgramCommandArray {
        if let ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(ProgramCommandArray::new()));
        }
        match self.data {
            ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_OK_GET_STATE(&mut self) -> ProgramCommandArray {
        if self.has_OK_GET_STATE() {
            match self.data.take() {
                ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(v)) => v,
                _ => panic!(),
            }
        } else {
            ProgramCommandArray::new()
        }
    }

    // .qni.api.ErrorResponse ERR = 255;


    pub fn get_ERR(&self) -> &ErrorResponse {
        match self.data {
            ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(ref v)) => v,
            _ => <ErrorResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ERR(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_ERR(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ERR(&mut self, v: ErrorResponse) {
        self.data = ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ERR(&mut self) -> &mut ErrorResponse {
        if let ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(ErrorResponse::new()));
        }
        match self.data {
            ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ERR(&mut self) -> ErrorResponse {
        if self.has_ERR() {
            match self.data.take() {
                ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(v)) => v,
                _ => panic!(),
            }
        } else {
            ErrorResponse::new()
        }
    }
}

impl ::protobuf::Message for ProgramResponse {
    fn is_initialized(&self) -> bool {
        if let Some(ProgramResponse_oneof_data::OK_GET_STATE(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProgramResponse_oneof_data::ERR(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramResponse_oneof_data::OK_GET_STATE(is.read_message()?));
                },
                255 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramResponse_oneof_data::ERR(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramResponse_oneof_data::OK_GET_STATE(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProgramResponse_oneof_data::ERR(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramResponse_oneof_data::OK_GET_STATE(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProgramResponse_oneof_data::ERR(ref v) => {
                    os.write_tag(255, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramResponse {
        ProgramResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProgramCommandArray>(
                "OK_GET_STATE",
                ProgramResponse::has_OK_GET_STATE,
                ProgramResponse::get_OK_GET_STATE,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ErrorResponse>(
                "ERR",
                ProgramResponse::has_ERR,
                ProgramResponse::get_ERR,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProgramResponse>(
                "ProgramResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProgramResponse {
        static instance: ::protobuf::rt::LazyV2<ProgramResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProgramResponse::new)
    }
}

impl ::protobuf::Clear for ProgramResponse {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProgramMessage {
    // message oneof groups
    pub data: ::std::option::Option<ProgramMessage_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProgramMessage {
    fn default() -> &'a ProgramMessage {
        <ProgramMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ProgramMessage_oneof_data {
    REQ(ProgramRequest),
    RES(ProgramResponse),
    ACCEPT_RES(u32),
}

impl ProgramMessage {
    pub fn new() -> ProgramMessage {
        ::std::default::Default::default()
    }

    // .qni.api.ProgramRequest REQ = 10;


    pub fn get_REQ(&self) -> &ProgramRequest {
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(ref v)) => v,
            _ => <ProgramRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_REQ(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_REQ(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_REQ(&mut self, v: ProgramRequest) {
        self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(v))
    }

    // Mutable pointer to the field.
    pub fn mut_REQ(&mut self) -> &mut ProgramRequest {
        if let ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(ProgramRequest::new()));
        }
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_REQ(&mut self) -> ProgramRequest {
        if self.has_REQ() {
            match self.data.take() {
                ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(v)) => v,
                _ => panic!(),
            }
        } else {
            ProgramRequest::new()
        }
    }

    // .qni.api.ProgramResponse RES = 11;


    pub fn get_RES(&self) -> &ProgramResponse {
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::RES(ref v)) => v,
            _ => <ProgramResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_RES(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_RES(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::RES(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_RES(&mut self, v: ProgramResponse) {
        self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::RES(v))
    }

    // Mutable pointer to the field.
    pub fn mut_RES(&mut self) -> &mut ProgramResponse {
        if let ::std::option::Option::Some(ProgramMessage_oneof_data::RES(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::RES(ProgramResponse::new()));
        }
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::RES(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_RES(&mut self) -> ProgramResponse {
        if self.has_RES() {
            match self.data.take() {
                ::std::option::Option::Some(ProgramMessage_oneof_data::RES(v)) => v,
                _ => panic!(),
            }
        } else {
            ProgramResponse::new()
        }
    }

    // uint32 ACCEPT_RES = 12;


    pub fn get_ACCEPT_RES(&self) -> u32 {
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::ACCEPT_RES(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_ACCEPT_RES(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_ACCEPT_RES(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(ProgramMessage_oneof_data::ACCEPT_RES(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ACCEPT_RES(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::ACCEPT_RES(v))
    }
}

impl ::protobuf::Message for ProgramMessage {
    fn is_initialized(&self) -> bool {
        if let Some(ProgramMessage_oneof_data::REQ(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProgramMessage_oneof_data::RES(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::REQ(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::RES(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(ProgramMessage_oneof_data::ACCEPT_RES(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramMessage_oneof_data::REQ(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProgramMessage_oneof_data::RES(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProgramMessage_oneof_data::ACCEPT_RES(v) => {
                    my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &ProgramMessage_oneof_data::REQ(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProgramMessage_oneof_data::RES(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProgramMessage_oneof_data::ACCEPT_RES(v) => {
                    os.write_uint32(12, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramMessage {
        ProgramMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProgramRequest>(
                "REQ",
                ProgramMessage::has_REQ,
                ProgramMessage::get_REQ,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProgramResponse>(
                "RES",
                ProgramMessage::has_RES,
                ProgramMessage::get_RES,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "ACCEPT_RES",
                ProgramMessage::has_ACCEPT_RES,
                ProgramMessage::get_ACCEPT_RES,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProgramMessage>(
                "ProgramMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProgramMessage {
        static instance: ::protobuf::rt::LazyV2<ProgramMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProgramMessage::new)
    }
}

impl ::protobuf::Clear for ProgramMessage {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum FontStyle {
    REGULAR = 0,
    ITALIC = 1,
    BOLD = 2,
}

impl ::protobuf::ProtobufEnum for FontStyle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FontStyle> {
        match value {
            0 => ::std::option::Option::Some(FontStyle::REGULAR),
            1 => ::std::option::Option::Some(FontStyle::ITALIC),
            2 => ::std::option::Option::Some(FontStyle::BOLD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FontStyle] = &[
            FontStyle::REGULAR,
            FontStyle::ITALIC,
            FontStyle::BOLD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FontStyle>("FontStyle", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FontStyle {
}

impl ::std::default::Default for FontStyle {
    fn default() -> Self {
        FontStyle::REGULAR
    }
}

impl ::protobuf::reflect::ProtobufValue for FontStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum TextAlign {
    LEFT = 0,
    RIGHT = 1,
    CENTER = 2,
}

impl ::protobuf::ProtobufEnum for TextAlign {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TextAlign> {
        match value {
            0 => ::std::option::Option::Some(TextAlign::LEFT),
            1 => ::std::option::Option::Some(TextAlign::RIGHT),
            2 => ::std::option::Option::Some(TextAlign::CENTER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TextAlign] = &[
            TextAlign::LEFT,
            TextAlign::RIGHT,
            TextAlign::CENTER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TextAlign>("TextAlign", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TextAlign {
}

impl ::std::default::Default for TextAlign {
    fn default() -> Self {
        TextAlign::LEFT
    }
}

impl ::protobuf::reflect::ProtobufValue for TextAlign {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rqni-api.proto\x12\x07qni.api\x1a\x1egoogle/protobuf/duration.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.pro\
    to\"!\n\x0bStringArray\x12\x12\n\x04data\x18\x01\x20\x03(\tR\x04data\"B\
    \n\rErrorResponse\x12\x19\n\x08req_type\x18\x01\x20\x01(\tR\x07reqType\
    \x12\x16\n\x06reason\x18\x02\x20\x01(\tR\x06reason\"\xfb\x05\n\x0cInputR\
    equest\x122\n\x06expire\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampR\x06expire\x12.\n\x05TOUCH\x18\n\x20\x01(\x0b2\x16.google.protobuf.E\
    mptyH\0R\x05TOUCH\x12.\n\x05ENTER\x18\x0b\x20\x01(\x0b2\x16.google.proto\
    buf.EmptyH\0R\x05ENTER\x120\n\x06ANYKEY\x18\x0c\x20\x01(\x0b2\x16.google\
    .protobuf.EmptyH\0R\x06ANYKEY\x122\n\x07BOOLEAN\x18\r\x20\x01(\x0b2\x16.\
    google.protobuf.EmptyH\0R\x07BOOLEAN\x12*\n\x03STR\x18\x14\x20\x01(\x0b2\
    \x16.google.protobuf.EmptyH\0R\x03STR\x12\x20\n\x0bSTR_MAX_LEN\x18\x15\
    \x20\x01(\rH\0R\tSTRMAXLEN\x125\n\nSTR_SELECT\x18\x16\x20\x01(\x0b2\x14.\
    qni.api.StringArrayH\0R\tSTRSELECT\x12*\n\x03INT\x18\x1e\x20\x01(\x0b2\
    \x16.google.protobuf.EmptyH\0R\x03INT\x12\x20\n\x0bINT_MAX_LEN\x18\x1f\
    \x20\x01(\rH\0R\tINTMAXLEN\x12.\n\x05FLOAT\x18(\x20\x01(\x0b2\x16.google\
    .protobuf.EmptyH\0R\x05FLOAT\x12$\n\rFLOAT_MAX_LEN\x18)\x20\x01(\rH\0R\
    \x0bFLOATMAXLEN\x12,\n\x04DATE\x182\x20\x01(\x0b2\x16.google.protobuf.Em\
    ptyH\0R\x04DATE\x124\n\x08DATETIME\x183\x20\x01(\x0b2\x16.google.protobu\
    f.EmptyH\0R\x08DATETIME\x12,\n\x04TIME\x184\x20\x01(\x0b2\x16.google.pro\
    tobuf.EmptyH\0R\x04TIME\x12.\n\x05COLOR\x18<\x20\x01(\x0b2\x16.google.pr\
    otobuf.EmptyH\0R\x05COLORB\x06\n\x04data\"\xd8\x02\n\rInputResponse\x12.\
    \n\x05EMPTY\x18\n\x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\x05EMPTY\
    \x12\x1a\n\x07BOOLEAN\x18\x14\x20\x01(\x08H\0R\x07BOOLEAN\x12\x12\n\x03S\
    TR\x18\x15\x20\x01(\tH\0R\x03STR\x12\x12\n\x03INT\x18\x16\x20\x01(\x05H\
    \0R\x03INT\x12\x16\n\x05FLOAT\x18\x17\x20\x01(\x02H\0R\x05FLOAT\x120\n\
    \x04DATE\x18\x1e\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\0R\x04DATE\
    \x128\n\x08DATETIME\x18\x1f\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\
    \0R\x08DATETIME\x12/\n\x04TIME\x18\x20\x20\x01(\x0b2\x19.google.protobuf\
    .DurationH\0R\x04TIME\x12\x16\n\x05COLOR\x18(\x20\x01(\rH\0R\x05COLORB\
    \x06\n\x04data\"Z\n\x16ConsolePrintButtonData\x12,\n\x05value\x18\x01\
    \x20\x01(\x0b2\x16.qni.api.InputResponseR\x05value\x12\x12\n\x04text\x18\
    \x02\x20\x01(\tR\x04text\"\xe1\x02\n\x10ConsolePrintData\x12\x16\n\x05PR\
    INT\x18\n\x20\x01(\tH\0R\x05PRINT\x12\x1f\n\nPRINT_LINE\x18\x0b\x20\x01(\
    \tH\0R\tPRINTLINE\x12D\n\x0cPRINT_BUTTON\x18\x0c\x20\x01(\x0b2\x1f.qni.a\
    pi.ConsolePrintButtonDataH\0R\x0bPRINTBUTTON\x123\n\x08NEW_LINE\x18\x14\
    \x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\x07NEWLINE\x125\n\tDRAW_LIN\
    E\x18\x15\x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\x08DRAWLINE\x12!\n\
    \x0bDELETE_LINE\x18\x1e\x20\x01(\rH\0R\nDELETELINE\x127\n\nCLEAR_LINE\
    \x18\x1f\x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\tCLEARLINEB\x06\n\
    \x04data\"c\n\x04Font\x12\x1f\n\x0bfont_family\x18\x01\x20\x01(\tR\nfont\
    Family\x12\x1b\n\tfont_size\x18\x02\x20\x01(\x02R\x08fontSize\x12\x1d\n\
    \nfont_style\x18\x03\x20\x01(\rR\tfontStyle\"\xe3\x01\n\x12ConsoleSettin\
    gItem\x12\x1f\n\nTEXT_COLOR\x18\n\x20\x01(\rH\0R\tTEXTCOLOR\x12\x1f\n\nB\
    ACK_COLOR\x18\x0b\x20\x01(\rH\0R\tBACKCOLOR\x12)\n\x0fHIGHLIGHT_COLOR\
    \x18\x0c\x20\x01(\rH\0R\x0eHIGHLIGHTCOLOR\x12#\n\x04FONT\x18\x14\x20\x01\
    (\x0b2\r.qni.api.FontH\0R\x04FONT\x123\n\nTEXT_ALIGN\x18\x15\x20\x01(\
    \x0e2\x12.qni.api.TextAlignH\0R\tTEXTALIGNB\x06\n\x04data\"7\n\x0eConsol\
    eRequest\x12\x1d\n\tGET_STATE\x18\x14\x20\x01(\x04H\0R\x08GETSTATEB\x06\
    \n\x04data\"\x8d\x01\n\x0fConsoleResponse\x12\x10\n\x03tag\x18\x01\x20\
    \x01(\rR\x03tag\x123\n\x08OK_INPUT\x18\n\x20\x01(\x0b2\x16.qni.api.Input\
    ResponseH\0R\x07OKINPUT\x12+\n\x03ERR\x18\xff\x01\x20\x01(\x0b2\x16.qni.\
    api.ErrorResponseH\0R\x03ERRB\x06\n\x04data\"s\n\x0eConsoleMessage\x12+\
    \n\x03REQ\x18\n\x20\x01(\x0b2\x17.qni.api.ConsoleRequestH\0R\x03REQ\x12,\
    \n\x03RES\x18\x0b\x20\x01(\x0b2\x18.qni.api.ConsoleResponseH\0R\x03RESB\
    \x06\n\x04data\"\x91\x01\n\x0eProgramCommand\x121\n\x05PRINT\x18\n\x20\
    \x01(\x0b2\x19.qni.api.ConsolePrintDataH\0R\x05PRINT\x12D\n\x0eUPDATE_SE\
    TTING\x18\x0b\x20\x01(\x0b2\x1b.qni.api.ConsoleSettingItemH\0R\rUPDATESE\
    TTINGB\x06\n\x04data\"J\n\x13ProgramCommandArray\x123\n\x08commands\x18\
    \x01\x20\x03(\x0b2\x17.qni.api.ProgramCommandR\x08commands\"Y\n\x0eProgr\
    amRequest\x12\x10\n\x03tag\x18\x01\x20\x01(\rR\x03tag\x12-\n\x05INPUT\
    \x18\n\x20\x01(\x0b2\x15.qni.api.InputRequestH\0R\x05INPUTB\x06\n\x04dat\
    a\"\x88\x01\n\x0fProgramResponse\x12@\n\x0cOK_GET_STATE\x18\x0c\x20\x01(\
    \x0b2\x1c.qni.api.ProgramCommandArrayH\0R\nOKGETSTATE\x12+\n\x03ERR\x18\
    \xff\x01\x20\x01(\x0b2\x16.qni.api.ErrorResponseH\0R\x03ERRB\x06\n\x04da\
    ta\"\x94\x01\n\x0eProgramMessage\x12+\n\x03REQ\x18\n\x20\x01(\x0b2\x17.q\
    ni.api.ProgramRequestH\0R\x03REQ\x12,\n\x03RES\x18\x0b\x20\x01(\x0b2\x18\
    .qni.api.ProgramResponseH\0R\x03RES\x12\x1f\n\nACCEPT_RES\x18\x0c\x20\
    \x01(\rH\0R\tACCEPTRESB\x06\n\x04data*.\n\tFontStyle\x12\x0b\n\x07REGULA\
    R\x10\0\x12\n\n\x06ITALIC\x10\x01\x12\x08\n\x04BOLD\x10\x02*,\n\tTextAli\
    gn\x12\x08\n\x04LEFT\x10\0\x12\t\n\x05RIGHT\x10\x01\x12\n\n\x06CENTER\
    \x10\x02b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
